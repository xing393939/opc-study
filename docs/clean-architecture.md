### 整洁架构

#### 第2部分 编程范式
* [架构整洁之道 3~6章读书笔记](https://cloud.tencent.com/developer/article/1834412)
* [架构整洁之道-03 编程范式-函数式编程](https://juejin.cn/post/7027679199326371854)
* [如何评价 Bob 大叔的新书《架构整洁之道》](https://www.zhihu.com/question/301498382/answer/1018334384)
* [架构整洁之道, 看这一篇就够了](https://mp.weixin.qq.com/s/Kd1T40KZWvdThKC3IN6n-Q)

```
编程范式不是为程序员提供了更多的能力，而是限制了能力：
结构化编程限制了控制权的直接转移；
面向对象编程限制了控制权的间接转移；
函数式编程限制了赋值；

所谓限制控制权直接转移，即是限制了goto语句的使用。要求用顺序结构、分支结构、循环结构这三种结构构造出任何程序。好处是方便把大项目拆分成一个个可证伪的组件。

所谓限制控制权的间接转移，即是限制了函数指针的使用。指针的使用，就是代码在原来的流程里不继续执行了，转而去执行别的代码，但具体执行了啥代码你也不知道，你只调了个函数指针或者接口。相对于goto的直接转移，这叫做控制权的间接转移。面向对象编程对于架构的启发最大在于：多态。这使得跨越组件编程变得更安全，同时也是依赖倒置的基础。

函数式编程中的变量不再改变。我们的所有并发程序（多核多线程）的问题，如果没有可变变量，就不再出现了。当然，这是不可能的，我们可以通过将需要修改状态的部分和不需要修改的部分分隔成单独的组件，在不需要修改状态的组件中使用函数式编程，提高系统的稳定性和效率。
```

#### 第3部分 设计模式
* 单一职责SRP（Single Responsibility Principle）；
  * 一个模块有且只能对一个角色负责，不是每个模块都只做一件事。
  * 例如一个类既被CTO又被COO调用，COO提出修改需求导致CTO的调用出现bug
* 开闭原则OCP（Open Closed Principle）；
  * 对扩展开放，对修改关闭
* 里氏替换LSP（Liskov Substitution Principle）；
  * 父类出现的地方可以用子类进行替换。具体到架构层面：该原则指导的是接口与其实现方式。
* 接口隔离ISP（Interface Segregation Principle）；
  * 不依赖任何不需要的方法、类或组件
* 依赖反转DIP（Dependency Inversion Principle）；
  * 组件之间，接口放在边界的哪边，依赖就指向哪边。

#### 第4部分 组件构建原则
* 组件的聚合原则
  * 复用发布原则(REP)：只要复用一段代码就把它抽成组件。如何抽组件，需要依据共同封闭原则、共同复用原则。
  * 共同封闭原则(CCP)：为了相同目的而同时修改的类，应该放在同一个组件中。共同封闭原则是组件视角下的单一职责原则。
  * 共同复用原则(CRP)：不要强迫一个组件依赖它不需要的东西。共同复用原则是组件视觉下的接口隔离原则。

<table>
    <tr>
        <th>类型</th>
        <th>范式/原则</th>
        <th>对类/架构的意义</th>  
    </tr>
    <tr>
        <td rowspan="3">编程范式<br>如何组织代码</td>
        <td>结构化编程</td>
        <td>拆分不同的函数、模块、组件</td>
    </tr>
    <tr>
        <td>面向对象编程</td>
        <td>依赖导致基础</td>
    </tr>
    <tr>
        <td>函数式编程</td>
        <td>拆分可变和不可变</td>
    </tr>
    <tr>
        <td rowspan="5">设计原则<br>如何组织类</td>
        <td>单一职责原则</td>
        <td>分隔不同角色依赖的代码</td>
    </tr>
    <tr>
        <td>里氏替换原则</td>
        <td>指导接口和实现方式</td>
    </tr>
    <tr>
        <td>接口隔离原则</td>
        <td>指导接口设计</td>
    </tr>
    <tr>
        <td>依赖倒置原则</td>
        <td>指导组件间依赖的方向</td>
    </tr>
    <tr>
        <td>开闭原则</td>
        <td>指导整体的类设计</td>
    </tr>
    <tr>
        <td rowspan="3">组件聚合原则<br>类归入哪些模块</td>
        <td>复用发布原则</td>
        <td rowspan="3">指导组件拆分的粒度</td>
    </tr>
    <tr>
        <td>共同封闭原则=单一职责</td>
    </tr>
    <tr>
        <td>共同复用原则=接口隔离</td>
    </tr>
    <tr>
        <td rowspan="3">组件依赖原则<br>模块相互依赖</td>
        <td>无循环依赖原则</td>
        <td>指导分层</td>
    </tr>
    <tr>
        <td>稳定依赖原则</td>
        <td>指导分层</td>
    </tr>
    <tr>
        <td>依赖抽象原则</td>
        <td>有利于组件扩展</td>
    </tr>
</table>




























