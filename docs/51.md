### 设计模式和案例

#### 重写、重载、面向对象四大特性
1. [Java基础之多态的实现重载 vs 重写](https://www.jianshu.com/p/e838c4636a57)
1. 重写（override）：参数和返回值都必须和父类相同
1. 重载（overload）：参数必须不同，返回值可以相同
1. 面向对象四大特性：
  * 封装
  * 抽象
  * 继承：子类使用父类的方法
  * 多态：父类使用子类的方法（重写）

#### 策略模式
1. 案例：鸭有绿头鸭、红头鸭、橡皮鸭；鸭的特性有飞、叫
1. 坏的设计1：基类有鸭（包含方法fly、quack），橡皮鸭继承基类（重写方法fly、quack）
1. 坏的设计2：基类有鸭，接口有Flyable、Quackable，子类通过setFlyBehavior、setQuackBehavior来实现飞、叫
1. 好的设计：
  * 基类有鸭（包含方法fly、quack，包含属性flyBehavior、quackBehavior）
  * 每个子类都继承基类（构造函数赋值不同的flyBehavior、quackBehavior）
1. oo原则：
  * 封装变化
  * 多用组合，少用继承
  * 针对接口编程，不针对实现编程
1. oo模式：策略之间可以相互替换，让策略的变化独立于使用策略的客户

#### 观察者模式
1. 案例：主题有温度、湿度、气压；显示屏有三个
1. 坏的设计：面向过程的写法，当主题变化时，初始化三个显示屏并执行update方法
1. 好的设计：
  * 接口有Subject（包含方法registerObserver、removeObserver、notifyObservers），对应的实现类是WeatherData（包含属性Temperature、Humidity、Pressure）
  * 接口有Observer（包含方法update），对应的实现类是三个显示屏
1. oo原则：为交互对象之间的松耦合设计而努力
1. oo模式：在对象之间定义一对多的依赖，这样一来，当一个对象改变状态，依赖它的对象都会收到通知

#### 装饰者模式
1. 案例：星巴克的咖啡有室内混搭、焦炒、脱咖啡因，调料有牛奶、豆浆、摩卡
1. 坏的设计1：基类有Beverage（包含方法getDescription、cost），子类是HouseBlendWithMilk、HouseBlendWithSoy等等
1. 坏的设计2：基类有Beverage（包含方法getDescription、cost，包含属性Milk、Soy、Mocha），子类HouseBlend（通过setter修改属性Milk、Soy、Mocha，重写cost方法）
1. 好的设计：
  * 基类有Beverage（包含方法getDescription、cost），子类有HouseBlend、DarkRoast、Decaf和CondimentDecorator（包含属性beverage）
  * CondimentDecorator的子类有Milk、Soy、Mocha
  * 例如要一个HouseBlendWithMilk类，先实例化HouseBlend，再用Milk类来装饰
1. oo原则：对扩展开放，对修改关闭
1. oo模式：动态的将责任附加到对象上（而不是通过继承）

#### 工厂模式
1. 案例：披萨店生成各种口味披萨（简单工厂）；纽约店和芝加哥店同口味的披萨做法不同（工厂方法）；纽约店和芝加哥店需要各种本地原料（抽象工厂）
1. 坏的设计：对比简单工厂模式，用面向过程的写法，在客户端写if-else语句来创建不同的披萨
1. 好的设计：简单工厂模式
1. oo原则：依赖抽象，不要依赖具体类
1. oo模式：
  * 工厂方法：定义了创建对象的接口，由子类来决定如何创建
  * 抽象工厂：定义了创建产品家族的接口，同时产品也是抽象

#### 单例模式
1. 案例：用锅炉融化牛奶和巧克力，锅炉只能有一个
1. 坏的设计：用全局变量来保存类实例
1. 好的设计：用单例模式，可以延迟实例化，需注意并发导致实例化多次
1. oo模式：确保一个类只有一个实例

#### 命令模式
1. 案例1：用户点菜下单，服务员把单子交给厨师，厨师做好菜。服务员和厨师解耦，服务员不需要知道是哪个厨师做、如何做这些菜
1. 案例2：遥控器按钮控制五种家电的开和关：卧室灯、厨房灯、吊扇、车库门、音响
1. 坏的设计：面向过程的写法，遥控器写大量的if-else来实现按钮和对应的事件
1. 好的设计：控制器是Invoker，Command数组绑定5个Command，Command关联卧室灯、厨房灯、吊扇、车库门、音响
1. oo模式：将请求封装成对象，让请求成为标准化的处理物品

#### 适配器模式
1. 案例：把火鸡当作鸭子，需要一个继承鸭类的适配器类
1. 坏的设计：直接修改现有的火鸡类
1. 好的设计：设计一个继承鸭类的适配器类，这样就不用修改原有的代码
1. oo模式：将一个类转换成用户期望的另一个类

#### 外观模式
1. 案例：打开家庭影院模式：打开爆米花机、灯光10%、屏幕放下、打开投影机、音响设置环绕立体音、DVD播放影片
1. 坏的设计：面向过程的写法，客户端直接写打开爆米花机、灯光10%、屏幕放下、打开投影机、音响设置环绕立体音、DVD播放影片
1. 好的设计：设计一个外观类，提供简单的操作接口，客户端只需要和外观类打交道
1. oo原则：最少知道原则
1. oo模式：封装内部子系统，对外提供统一的、简单的接口

#### 模板方法
1. 案例：星巴克泡咖啡/茶的秘方共同点：把水煮沸、泡咖啡/茶、泡好倒入被子、加上调料
1. 坏的设计：泡咖啡和泡茶独自写一个类，缺点是两者有重复的代码
1. 好的设计：设计一个公共的抽象类，泡咖啡和泡茶继承它并实现有差异的部分










