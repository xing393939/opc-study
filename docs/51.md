### 设计模式和案例

#### 重写、重载、面向对象四大特性
1. [Java基础之多态的实现重载 vs 重写](https://www.jianshu.com/p/e838c4636a57)
1. 重写（override）：参数和返回值都必须和父类相同
1. 重载（overload）：参数必须不同，返回值可以相同
1. 面向对象四大特性：
  * 封装
  * 抽象
  * 继承：子类使用父类的方法
  * 多态：父类使用子类的方法（重写）

#### 策略模式
1. 案例：鸭有绿头鸭、红头鸭、橡皮鸭；鸭的特性有飞、叫
1. 坏的设计1：基类有鸭（包含方法fly、quack），橡皮鸭继承基类（重写方法fly、quack）
1. 坏的设计2：基类有鸭，接口有Flyable、Quackable，每个子类都要继承基类和Flyable、Quackable
1. 好的设计：
  * 基类有鸭（包含方法fly、quack，包含属性flyBehavior、quackBehavior）
  * 每个子类都继承基类（构造函数赋值不同的flyBehavior、quackBehavior）
1. oo原则：
  * 封装变化
  * 多用组合，少用继承
  * 针对接口编程，不针对实现编程
1. oo模式：策略之间可以相互替换，让策略的变化独立于使用策略的客户

#### 观察者模式
1. 案例：主题有温度、湿度、气压；显示屏有三个
1. 坏的设计：面向过程的写法，当主题变化时，初始化三个显示屏并执行update方法
1. 好的设计：
  * 接口有Subject（包含方法registerObserver、removeObserver、notifyObservers），对应的实现类是WeatherData（包含属性Temperature、Humidity、Pressure）
  * 接口有Observer（包含方法update），对应的实现类是三个显示屏
1. oo原则：为交互对象之间的松耦合设计而努力
1. oo模式：在对象之间定义一对多的依赖，这样一来，当一个对象改变状态，依赖它的对象都会收到通知

#### 装饰者模式
1. 案例：星巴克的咖啡有室内混搭、焦炒、脱咖啡因，调料有牛奶、豆浆、摩卡
1. 坏的设计1：基类有Beverage（包含方法getDescription、cost），子类是HouseBlendWithMilk、HouseBlendWithSoy等等
1. 坏的设计2：基类有Beverage（包含方法getDescription、cost，包含属性Milk、Soy、Mocha），子类HouseBlend（通过setter修改属性Milk、Soy、Mocha，重写cost方法）
1. 好的设计：
  * 基类有Beverage（包含方法getDescription、cost），子类有HouseBlend、DarkRoast、Decaf和CondimentDecorator（包含属性beverage）
  * CondimentDecorator的子类有Milk、Soy、Mocha
  * 例如要一个HouseBlendWithMilk类，先实例化HouseBlend，再用Milk类来装饰
1. oo原则：对扩展开放，对修改关闭
1. oo模式：动态的将责任附加到对象上（而不是通过继承）

#### 工厂模式
1. 案例：披萨店生成各种口味披萨（简单工厂）；纽约店和芝加哥店同口味的披萨做法不同（工厂方法）；纽约店和芝加哥店需要各种本地原料（抽象工厂）
1. 坏的设计：对比简单工厂模式，用面向过程的写法，在客户端写if-else语句来创建不同的披萨
1. 好的设计：简单工厂模式
1. oo原则：依赖抽象，不要依赖具体类
1. oo模式：
  * 工厂方法：定义了创建对象的接口，由子类来决定如何创建
  * 抽象工厂：定义了创建产品家族的接口，同时产品也是抽象



