### 数据结构与算法之美

#### 资料
1. [数据结构与算法之美 - 极客时间](https://time.geekbang.org/column/intro/126)
1. 常用的十个结构：数组、链表、栈、队列、散列表、二叉树、二叉堆、跳表、图、前缀树。
1. 常用的十个算法：递归、排序、二分查找、哈希算法、图的搜索、字符串匹配、贪心算法、分治算法、回溯算法、动态规划。
1. 算法复杂度：
  * 最好情况
  * 最坏情况
  * 平均情况：例如有N种情况，则将N种情况的耗时相加再除以N
  * 均摊时间：它的分析方法叫摊还分析，暂时不学。

#### 数组、链表、栈、队列、散列表、二叉树、二叉堆、跳表
1. 数组：支持随机访问，基于数组下标的访问是O(1)，插入和删除则需要搬迁内存
1. 链表：单向链表、双向链表、循环链表。给单向链表增加一个fake头节点可以简化代码逻辑。
1. 栈：可以用数组实现（需要支持动态扩容），也可以用链表实现（比数组更占内存）。
1. 队列：同样可以用数组、链表实现
  * 普通队列
  * 双端队列
  * 优先队列：优先级高的先出（可以用二叉堆实现）
1. 散列表：解决哈希冲突的两个办法：
  * 开放寻址法：当前位置i被占用，则检查i+1，i+1被占用，则检查i+2
  * 链表法
1. 散列表如何实现工业级，以java的HashMap举例：
    * 初始容量为16
    * 当元素个数超过当前容量的75%时，自动扩容成2倍大小（此时有新旧两个散列表，当数据全部迁移后删除旧表）
    * 当链表长度 > 8，转成红黑树，当长度 < 8，退化成链表（数据量小时，红黑树要维护平衡，反而不如链表）
1. 二叉树：
  * 满二叉树：叶子都是全的
  * 完全二叉树：用数组存储节点的时候都是连续的，不需要用null来填空节点
  * 二叉查找树(二叉排序树)：左边所有节点 < 根节点 < 右边所有节点，搜索节点的时间复杂度是O(log n)
  * 二叉查找树的自平衡问题：树在一个分支上无限延长，导致搜索节点的时间复杂度退化成O(n)
    * 自平衡的方式：红黑树、AVL树
  * 散列表CURD是O(n)，平衡二叉查找树的CURD是O(log n)，为什么还会用二叉查找树？
    * 二叉查找树在O(n)时间内即可打印排序好的数据
    * 散列表扩容缩容时性能不稳定
    * 散列表的哈希冲突严重时，O(n)不一定快于二叉查找树的O(log n)
    * 散列表的实现需要关注扩容、缩容、哈希算法、哈希冲突，而二叉查找树主要关注自平衡
  * 红黑树是基于23树的，[理解了23树就理解了红黑树](https://blog.csdn.net/fei33423/article/details/79132930)  
1. 二叉堆：必须是完全二叉树，父节点必须>=或<=子节点。以小顶堆为例：
  * 插入节点O(log n)：新节点先插入小顶推最后一个位置，若 < 父节点则交换
  * 删除节点O(log n)：用小顶推最后一个位置的节点替换删除节点，若 > 子节点最小的那个则交换
  * 构建小顶堆O(log n)：先构建成完全二叉树，从底层第一个非叶子节点开始，若 > 子节点最小的那个则交换
1. 二叉堆的三个应用：
  * 优先级队列：大顶堆，堆顶元素就是优先级最高的
  * 求TopK：先建一个小顶堆，每次insert的时候和堆顶元素对比，小就忽略，大则加入
  * 求50%位的值：一个小顶堆和一个大顶堆，每次insert的时候和小顶堆堆顶元素比较，小则insert，大则insert大顶堆
1. 跳表：比红黑树的优秀的地方：
  * find、insert、delete 两者都是O(log n)，但是区间查找跳表依然是O(log n)
  * 跳表的代码比红黑树容易理解，好实现

#### 递归、排序、二分查找、哈希算法、图的搜索
1. 递归：斐波那契数列：F(n)=F(n-1)+F(n-2)
1. 排序：
  * O(n^2)：冒泡、插入、选择。其中选择排序最好最坏都是O(n^2)，且是不稳定排序。希尔排序是插入排序的优化版本。
  * O(n*log n)：归并、快排、堆排。其中归并的缺点是空间复杂度是O(n)，快排和堆排的缺点是非稳定排序。
    * 堆排不如快排原因1：排序过程中快排对元素的访问是局部顺序访问的，而堆排是随机的
    * 堆排不如快排原因2：相同的逆序度，快排元素交换的次数比堆排少（因为堆排建堆的时候破坏了有序度）
  * O(n)：计数、桶、基数。
    * 计数：元素必需是整数。若元素个数是n，最大值-最小值=m，最好是m<n。若m=n，时间复杂度是O(n^2)
    * 桶：元素可以是整数、小数，由于桶之间的等区间的，若第一个桶有n-1个元素，最后一个桶有1个元素，则时间复杂度是O(n*log n)
    * 基数：元素必须是整数或者ASCII字符。需要基于计数排序。若元素位数较多，n比较小，性能反而不佳。[vs快排](/images/radix-sort-vs-quick-sort.jpg)
1. 排序在c语言中的通用实现qsort：数据量小用归并；数据量大用快排，其中分区元素<=4时用插入。    
1. 二分查找的局限性：
  * 必须是顺序表结构，同时意味着需要连续内存
  * 必须是有序数据
1. 二分查找对比散列表和二叉树：其中二分查找和二叉树查找都是O(n)
  * 二分查找的优点在于不需要额外存储，缺点是需要连续内存
  * 二分查找不适合数据频繁更新的场景，而散列表和二叉树可以
  * 二分查找适合近似查找，如查找大于K的第一个元素，散列表和二叉树就比较难实现了
1. 哈希算法的6个常见应用：
  * 安全加密
  * 唯一标识：检查图片是否在现有图库中存在
  * 数据校验：下载完后对比哈希值
  * 散列函数
  * 负载均衡：通过哈希值取模保证会话粘滞（session sticky）
  * 数据分片：通过哈希值取模保证分片数据在指定的机器
  * 一致性哈希算法：保证加入新的机器节点后，现有的映射关系不变
1. 图的搜索：
  * 深度优先遍历、广度优先遍历也称为暴力搜索算法，适合图不大的算法
  * A星寻路算法属于高级算法
  
#### 图、前缀树
1. 图的基本概念：
  * 无向图：比如微信好友，i是j的好友，则j也是i的好友
  * 有向图：比如微博粉丝，i是j的粉丝，但j不是i的粉丝
  * 带权图：比如QQ的好友亲密度，i与j是好友，他们之间的亲密度是80%
1. 图的存储方式：
  * 邻接矩阵：数组A\[i]\[j]=1表示i是j的粉丝，A\[j]\[i]=0表示j不是i的粉丝
  * 邻接表：数组+链表，要查i关注的所有人，先查数组A[i]，再遍历链表。若要查i的所有粉丝，则再建一个逆邻接表。邻接表也能表示带权图。 
1. 图的遍历（顶点个数是n，边数是e）：
  * 深度优先遍历（Depth First Search）：空间复杂度O(n)，时间复杂度O(e)
  * 广度优先遍历（Breadth First Search）：空间复杂度O(n)，时间复杂度O(e)
1. 图中两点之间的最短路径：
  * Dijkstra单源最短路径算法：单源的意思是仅求两点之间的距离，时间复杂度O(n^2)，空间复杂度O(n)
  * Floyd多源最短路径算法：多源的意思是求出所有点之间的距离，时间复杂度是O(n^3)，空间复杂度O(n^2)，因为它用的邻接矩阵
1. 前缀树：属于多叉树，同一节点下的子节点按顺序排列（加快查找）
  * 前缀树不如散列表的地方1：字符串的字符集不能太大，否则空间消耗大、查询慢
  * 前缀树不如散列表的地方2：字符串的前缀重合比较多，否则空间消耗大
  * 前缀树不如散列表的地方3：因为业务场景不同，没有通用的实现库，需要自己实现前缀树
  * 前缀树不如散列表的地方4：使用了指针，内存不连续，对缓存不友好
  * 前缀树的优点：查询前缀匹配的所有集合
  
#### 字符串匹配、贪心算法、分治算法、回溯算法、动态规划
1. 字符串匹配（主串长度m，模式串长度n）
  * BF算法（Brute Force）：从主串位置0开始匹配，失败在从位置1开始匹配。最坏复杂度O(mn)
  * RK算法：基于BF，只不过每次匹配的时候是匹配的哈希值。最坏复杂度O(m+n)
  * KMP算法：从主串位置0开始匹配，失败则根据模式串的特点跳过k个位置开始匹配。最坏复杂度O(m+n)，空间复杂度O(n)
1. 贪心算法：例如找零问题，有1元、10元、100元的纸币，张数分别是c1、c10、c100，支付K元最少要用多少纸币？
1. 分治思想的案例：
  * 快速排序算法
  * 合并排序算法
  * 桶排序算法
  * 基数排序算法
  * 二分查找算法
  * 利用递归树求解算法复杂度
  * 分布式数据库的分片技术
1. 回溯算法：深度优先搜索算法利用的是回溯算法思想
1. 动态规划的例子1：求斐波那契的第n个元素
  * 方法1是递归：F(n) = F(n - 1) + F(n - 2)
  * 方法2是动态规划：for (i=2; i<n; i++) arr\[i] = arr\[i-1] + arr\[i-2]
1. 动态规划的例子2：金矿n=5、工人w=10（400金需5人；500金需5人；200金需3人；300金需4人；350金需3人）
  * 方法1是递归：F(n,w) = MAX(F(n-1,w), F(n-1,w-第n个金矿所需人数)+第n个金矿的黄金)
  * 方法2是动态规划：在表格中依次算出1个金矿10个工人的结果，2个金矿10个工人的结果……
1. 动态规划的例子3：物品n=5，背包承重w=9，物品依次重2，2，4，6，3
  * 方法1是递归：F(n,w) = MAX(F(n-1,w), F(n-1,w-items\[n-1])+items\[n-1]
  * 方法2是动态规划：在表格中依次算出1个物品承重9的结果，2个物品承重9的结果……

  
  