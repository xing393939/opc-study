### 数据结构与算法之美

#### 资料
1. [数据结构与算法之美 - 极客时间](https://time.geekbang.org/column/intro/126)
1. 常用的十个结构：数组、链表、栈、队列、散列表、二叉树、堆、跳表、图、前缀树。
1. 常用的十个算法：递归、排序、二分查找、搜索、哈希算法、贪心算法、分治算法、回溯算法、动态规划、字符串匹配。
1. 算法复杂度：
  * 最好情况
  * 最坏情况
  * 平均情况：例如有N种情况，则将N种情况的耗时相加再除以N
  * 均摊时间：它的分析方法叫摊还分析，暂时不学。

#### 数组、链表、栈、队列、散列表
1. 数组：支持随机访问，基于数组下标的访问是O(1)，插入和删除则需要搬迁内存
1. 链表：单向链表、双向链表、循环链表。给单向链表增加一个fake头节点可以简化代码逻辑。
1. 栈：可以用数组实现（需要支持动态扩容），也可以用链表实现（比数组更占内存）。
1. 队列：同样可以用数组、链表实现
  * 普通队列
  * 双端队列
  * 优先队列：优先级高的先出（可以用二叉堆实现）
1. 散列表：解决哈希冲突的两个办法：
  * 开放寻址法：当前位置i被占用，则检查i+1，i+1被占用，则检查i+2
  * 链表法
1. 二叉树：
  * 满二叉树：叶子都是全的
  * 完全二叉树：用数组存储节点的时候都是连续的，不需要用null来填空节点
  * 二叉查找树(二叉排序树)：左边所有节点 < 根节点 < 右边所有节点，搜索节点的时间复杂度是O(log n)
  * 二叉查找树的自平衡问题：树在一个分支上无限延长，导致搜索节点的时间复杂度退化到O(n)
    * 自平衡的方式：红黑树、AVL树
  * 二叉堆：必须是完全二叉树，父节点必须都比子节点小/大。以小顶堆为例：
    * 插入节点O(log n)：新节点先插入小顶推最后一个位置，若 < 父节点则交换
    * 删除节点O(log n)：把小顶推最后一个位置的节点挪到删除的节点处，若 > 子节点最小的那个则交换
    * 构建小顶堆O(log n)：先构建成完全二叉树，从底层第一个非叶子节点开始，若 > 子节点最小的那个则交换

#### 递归、排序、二分查找
1. 递归：斐波那契数列：F(n)=F(n-1)+F(n-2)
1. 排序：
  * O(n^2)：冒泡、插入、选择。其中选择排序最好最坏都是O(n^2)，且是不稳定排序。希尔排序是插入排序的优化版本。
  * O(n*log n)：归并、快排、堆排。其中归并的缺点是空间复杂度是O(n)，快排和堆排的缺点是非稳定排序。
  * O(n)：计数、桶、基数。
    * 计数：元素必需是整数。若元素个数是n，最大值-最小值=m，最好是m<n。若m=n，时间复杂度是O(n^2)
    * 桶：元素可以是整数、小数，由于桶之间的等区间的，若第一个桶有n-1个元素，最后一个桶有1个元素，则时间复杂度是O(n*log n)
    * 基数：元素必须是整数或者ASCII字符。
  