### 数据结构与算法之美

#### 资料
1. [数据结构与算法之美 - 极客时间](https://time.geekbang.org/column/intro/126)
1. 常用的十个结构：数组、链表、栈、队列、散列表、二叉树、二叉堆、跳表、图、前缀树。
1. 常用的十个算法：递归、排序、二分查找、哈希算法、搜索、贪心算法、分治算法、回溯算法、动态规划、字符串匹配。
1. 算法复杂度：
  * 最好情况
  * 最坏情况
  * 平均情况：例如有N种情况，则将N种情况的耗时相加再除以N
  * 均摊时间：它的分析方法叫摊还分析，暂时不学。

#### 数组、链表、栈、队列、散列表、二叉树、二叉堆、跳表
1. 数组：支持随机访问，基于数组下标的访问是O(1)，插入和删除则需要搬迁内存
1. 链表：单向链表、双向链表、循环链表。给单向链表增加一个fake头节点可以简化代码逻辑。
1. 栈：可以用数组实现（需要支持动态扩容），也可以用链表实现（比数组更占内存）。
1. 队列：同样可以用数组、链表实现
  * 普通队列
  * 双端队列
  * 优先队列：优先级高的先出（可以用二叉堆实现）
1. 散列表：解决哈希冲突的两个办法：
  * 开放寻址法：当前位置i被占用，则检查i+1，i+1被占用，则检查i+2
  * 链表法
1. 散列表如何实现工业级，以java的HashMap举例：
    * 初始容量为16
    * 当元素个数超过当前容量的75%时，自动扩容成2倍大小（此时有新旧两个散列表，当数据全部迁移后删除旧表）
    * 当链表长度 > 8，转成红黑树，当长度 < 8，退化成链表（数据量小时，红黑树要维护平衡，反而不如链表）
1. 二叉树：
  * 满二叉树：叶子都是全的
  * 完全二叉树：用数组存储节点的时候都是连续的，不需要用null来填空节点
  * 二叉查找树(二叉排序树)：左边所有节点 < 根节点 < 右边所有节点，搜索节点的时间复杂度是O(log n)
  * 二叉查找树的自平衡问题：树在一个分支上无限延长，导致搜索节点的时间复杂度退化到O(n)
    * 自平衡的方式：红黑树、AVL树
1. 二叉堆：必须是完全二叉树，父节点必须>=或<=子节点。以小顶堆为例：
  * 插入节点O(log n)：新节点先插入小顶推最后一个位置，若 < 父节点则交换
  * 删除节点O(log n)：把小顶推最后一个位置的节点挪到删除的节点处，若 > 子节点最小的那个则交换
  * 构建小顶堆O(log n)：先构建成完全二叉树，从底层第一个非叶子节点开始，若 > 子节点最小的那个则交换
1. 二叉堆的三个应用：
  * 优先级队列：大顶堆，堆顶元素就是优先级最高的
  * 求TopK：先建一个小顶堆，每次insert的时候和堆顶元素对比，小就忽略，大则加入
  * 求50%位的值：一个小顶堆和一个大顶堆，每次insert的时候和小顶堆堆顶元素比较，小则insert，大则insert大顶堆
1. 跳表：比红黑树的优秀的地方：
  * find、insert、delete 两者都是O(log n)，但是区间查找跳表依然是O(log n)
  * 跳表的代码比红黑树容易理解，好实现

#### 递归、排序、二分查找、哈希算法、搜索
1. 递归：斐波那契数列：F(n)=F(n-1)+F(n-2)
1. 排序：
  * O(n^2)：冒泡、插入、选择。其中选择排序最好最坏都是O(n^2)，且是不稳定排序。希尔排序是插入排序的优化版本。
  * O(n*log n)：归并、快排、堆排。其中归并的缺点是空间复杂度是O(n)，快排和堆排的缺点是非稳定排序。
    * 堆排不如快排原因1：排序过程中快排对元素的访问是局部顺序访问的，而堆排是随机的
    * 堆排不如快排原因2：相同的逆序度，快排元素交换的次数比堆排少（因为堆排建堆的时候破坏了有序度）
  * O(n)：计数、桶、基数。
    * 计数：元素必需是整数。若元素个数是n，最大值-最小值=m，最好是m<n。若m=n，时间复杂度是O(n^2)
    * 桶：元素可以是整数、小数，由于桶之间的等区间的，若第一个桶有n-1个元素，最后一个桶有1个元素，则时间复杂度是O(n*log n)
    * 基数：元素必须是整数或者ASCII字符。需要基于计数排序。
1. 排序在c语言中的通用实现qsort：数据量小用归并；数据量大用快排，其中分区元素<=4时用插入。    
1. 二分查找的局限性：
  * 必须是顺序表结构，同时意味着需要连续内存
  * 必须是有序数据
1. 二分查找对比散列表和二叉树：其中二分查找和二叉树查找都是O(n)
  * 二分查找的优点在于不需要额外存储，缺点是需要连续内存
  * 二分查找不适合数据频繁更新的场景，而散列表和二叉树可以
  * 二分查找适合近似查找，如查找大于K的第一个元素，散列表和二叉树就比较难实现了
1. 哈希算法的6个常见应用：
  * 安全加密
  * 唯一标识：检查图片是否在现有图库中存在
  * 数据校验：下载完后对比哈希值
  * 散列函数
  * 负载均衡：通过哈希值取模保证会话粘滞（session sticky）
  * 数据分片：通过哈希值取模保证分片数据在指定的机器
  * 一致性哈希算法：保证加入新的机器节点后，现有的映射关系不变