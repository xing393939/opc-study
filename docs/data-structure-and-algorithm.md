### 数据结构与算法之美

#### 资料
1. [数据结构与算法之美 - 极客时间](https://time.geekbang.org/column/intro/126)
1. 常用的十个结构：数组、链表、栈、队列、散列表、二叉树、二叉堆、跳表、图、前缀树。
1. 常用的十个算法：递归、排序、二分查找、哈希算法、图的搜索、字符串匹配、贪心算法、分治算法、回溯算法、动态规划。
1. 算法复杂度：
  * 最好情况
  * 最坏情况
  * 平均情况：例如有N种情况，则将N种情况的耗时相加再除以N
  * 均摊时间：它的分析方法叫摊还分析，暂时不学。

#### 数组、链表、栈、队列、散列表、二叉树、二叉堆、跳表
1. 数组：支持随机访问，基于数组下标的访问是O(1)，插入和删除则需要搬迁内存
1. 链表：单向链表、双向链表、循环链表。给单向链表增加一个fake头节点可以简化代码逻辑。
1. 栈：可以用数组实现（需要支持动态扩容），也可以用链表实现（比数组更占内存）。
1. 队列：同样可以用数组、链表实现
  * 普通队列
  * 双端队列
  * 优先队列：优先级高的先出（可以用二叉堆实现）
1. 散列表：解决哈希冲突的两个办法：
  * 开放寻址法：当前位置i被占用，则检查i+1，i+1被占用，则检查i+2
  * 链表法
1. 散列表如何实现工业级，以java的HashMap举例：
    * 初始容量为16
    * 当元素个数超过当前容量的75%时，自动扩容成2倍大小（此时有新旧两个散列表，当数据全部迁移后删除旧表）
    * 当链表长度 > 8，转成红黑树，当长度 < 8，退化成链表（数据量小时，红黑树要维护平衡，反而不如链表）
1. 二叉树：
  * 满二叉树：叶子都是全的
  * 完全二叉树：用数组存储节点的时候都是连续的，不需要用null来填空节点
  * 二叉查找树(二叉排序树)：左边所有节点 < 根节点 < 右边所有节点，搜索节点的时间复杂度是O(log n)
  * 二叉查找树的自平衡问题：树在一个分支上无限延长，导致搜索节点的时间复杂度退化成O(n)
    * 自平衡的方式：红黑树、AVL树
  * 散列表CURD是O(n)，平衡二叉查找树的CURD是O(log n)，为什么还会用二叉查找树？
    * 二叉查找树在O(n)时间内即可打印排序好的数据
    * 散列表扩容缩容时性能不稳定
    * 散列表的哈希冲突严重时，O(n)不一定快于二叉查找树的O(log n)
    * 散列表的实现需要关注扩容、缩容、哈希算法、哈希冲突，而二叉查找树主要关注自平衡
  * 红黑树是基于23树的，[理解了23树就理解了红黑树](https://blog.csdn.net/fei33423/article/details/79132930)  
1. 二叉堆：必须是完全二叉树，父节点必须>=或<=子节点。以小顶堆为例：
  * 插入节点O(log n)：新节点先插入小顶推最后一个位置，若 < 父节点则交换
  * 删除节点O(log n)：用小顶推最后一个位置的节点替换删除节点，若 > 子节点最小的那个则交换
  * 构建小顶堆O(log n)：先构建成完全二叉树，从底层第一个非叶子节点开始，若 > 子节点最小的那个则交换
1. 二叉堆的三个应用：
  * 优先级队列：大顶堆，堆顶元素就是优先级最高的
  * 求TopK：先建一个小顶堆，每次insert的时候和堆顶元素对比，小就忽略，大则加入
  * 求50%位的值：一个小顶堆和一个大顶堆，每次insert的时候和小顶堆堆顶元素比较，小则insert，大则insert大顶堆
1. 跳表：比红黑树的优秀的地方：
  * find、insert、delete 两者都是O(log n)，但zrank、zrange跳表依然是O(log n)
  * 跳表的代码比红黑树容易理解，好实现

#### 递归、排序、二分查找、哈希算法、图的搜索
1. 递归：斐波那契数列：F(n)=F(n-1)+F(n-2)
1. 排序：
  * O(n^2)：冒泡、插入、选择。其中选择排序最好最坏都是O(n^2)，且是不稳定排序。希尔排序是插入排序的优化版本。
  * O(n*log n)：归并、快排、堆排。其中归并的缺点是空间复杂度是O(n)，快排和堆排的缺点是非稳定排序。
    * 堆排不如快排原因1：排序过程中快排对元素的访问是局部顺序访问的，而堆排是随机的
    * 堆排不如快排原因2：相同的逆序度，快排元素交换的次数比堆排少（因为堆排建堆的时候破坏了有序度）
  * O(n)：计数、桶、基数。
    * 计数：元素必需是整数。若元素个数是n，最大值-最小值=m，最好是m<n。若m=n，时间复杂度是O(n^2)
    * 桶：元素可以是整数、小数，由于桶之间的等区间的，若第一个桶有n-1个元素，最后一个桶有1个元素，则时间复杂度是O(n*log n)
    * 基数：元素必须是整数或者ASCII字符。需要基于计数排序。若元素位数较多，n比较小，性能反而不佳。[vs快排](/images/radix-sort-vs-quick-sort.jpg)
1. 排序在c语言中的通用实现qsort：数据量小用归并；数据量大用快排，快排时区间元素<=4用插入。    
1. 二分查找的局限性：
  * 必须是顺序表结构，同时意味着需要连续内存
  * 必须是有序数据
1. 二分查找对比散列表和二叉树：其中二分查找和二叉树查找都是O(n)
  * 二分查找的优点在于不需要额外存储，缺点是需要连续内存
  * 二分查找不适合数据频繁更新的场景，而散列表和二叉树可以
  * 二分查找适合近似查找，如查找大于K的第一个元素，散列表和二叉树就比较难实现了
1. 哈希算法的6个常见应用：
  * 安全加密
  * 唯一标识：检查图片是否在现有图库中存在
  * 数据校验：下载完后对比哈希值
  * 散列函数
  * 负载均衡：通过哈希值取模保证会话粘滞（session sticky）
  * 数据分片：通过哈希值取模保证分片数据在指定的机器
  * 一致性哈希算法：保证加入新的机器节点后，现有的映射关系不变
1. 图的搜索：
  * 深度优先遍历、广度优先遍历也称为暴力搜索算法，适合图不大的算法
  * A星寻路算法属于高级算法
  
#### 图、前缀树
1. 图的基本概念：
  * 无向图：比如微信好友，i是j的好友，则j也是i的好友
  * 有向图：比如微博粉丝，i是j的粉丝，但j不是i的粉丝
  * 带权图：比如QQ的好友亲密度，i与j是好友，他们之间的亲密度是80%
1. 图的存储方式：
  * 邻接矩阵：数组A\[i]\[j]=1表示i是j的粉丝，A\[j]\[i]=0表示j不是i的粉丝
  * 邻接表：数组+链表，要查i关注的所有人，先查数组A[i]，再遍历链表。若要查i的所有粉丝，则再建一个逆邻接表。邻接表也能表示带权图。 
1. 图的遍历（顶点个数是n，边数是e）：
  * 深度优先遍历（Depth First Search）：空间复杂度O(n)，时间复杂度O(e)
  * 广度优先遍历（Breadth First Search）：空间复杂度O(n)，时间复杂度O(e)
1. 图中两点之间的最短路径：
  * Dijkstra单源最短路径算法：单源的意思是仅求两点之间的距离，时间复杂度O(n^2)，空间复杂度O(n)
  * Floyd多源最短路径算法：多源的意思是求出所有点之间的距离，时间复杂度是O(n^3)，空间复杂度O(n^2)，因为它用的邻接矩阵
1. 前缀树：属于多叉树，同一节点下的子节点按顺序排列（加快查找）
  * 前缀树不如散列表的地方1：字符串的字符集不能太大，否则空间消耗大、查询慢
  * 前缀树不如散列表的地方2：字符串的前缀重合比较多，否则空间消耗大
  * 前缀树不如散列表的地方3：因为业务场景不同，没有通用的实现库，需要自己实现前缀树
  * 前缀树不如散列表的地方4：使用了指针，内存不连续，对缓存不友好
  * 前缀树的优点：查询前缀匹配的所有集合
  
#### 字符串匹配、贪心算法、分治算法、回溯算法、动态规划
1. 字符串匹配（主串长度m，模式串长度n）
  * BF算法（Brute Force）：从主串位置0开始匹配，失败在从位置1开始匹配。最坏复杂度O(mn)
  * RK算法：基于BF，只不过每次匹配的时候是匹配的哈希值。最坏复杂度O(m+n)
  * KMP算法：从主串位置0开始匹配，失败则根据模式串的特点跳过k个位置开始匹配。最坏复杂度O(m+n)，空间复杂度O(n)
1. 贪心算法：例如找零问题，有1元、10元、100元的纸币，张数分别是c1、c10、c100，支付K元最少要用多少纸币？
1. 分治思想的案例：
  * 快速排序算法
  * 合并排序算法
  * 桶排序算法
  * 基数排序算法
  * 二分查找算法
  * 利用递归树求解算法复杂度
  * 分布式数据库的分片技术
1. 回溯算法：深度优先搜索算法利用的是回溯算法思想
1. 动态规划的例子1：求斐波那契的第n个元素
  * 方法1是递归：F(n) = F(n - 1) + F(n - 2)
  * 方法2是动态规划：for (i=2; i<n; i++) arr\[i] = arr\[i-1] + arr\[i-2]
1. 动态规划的例子2：金矿n=5、工人w=10（400金需5人；500金需5人；200金需3人；300金需4人；350金需3人）
  * 方法1是递归：F(n,w) = MAX(F(n-1,w), F(n-1,w-第n个金矿所需人数)+第n个金矿的黄金)
  * 方法2是动态规划：在表格中依次算出1个金矿10个工人的结果，2个金矿10个工人的结果……
1. 动态规划的例子3：物品n=5，背包承重w=9，物品依次重2，2，4，6，3
  * 方法1是递归：F(n,w) = MAX(F(n-1,w), F(n-1,w-items\[n-1])+items\[n-1])
  * 方法2是动态规划：在表格中依次算出1个物品承重9的结果，2个物品承重9的结果……

#### 高级篇
1. 位图：一千万个int32，存储需要40MB
  * 使用位图，数据范围是0~1亿，则需12MB
  * 使用位图，数据范围是0~10亿，则需120MB
1. 布隆过滤器：解决位图存储稀疏数据的问题
  * insert时使用K个哈希函数，把位图K个位置置1
  * search时使用K个哈希函数，查找对应位置是否为1
1. 朴素贝叶斯算法：
  * 先算p1=W1~Wn同时出现且短信是垃圾短信的概率 * 垃圾短信的百分比
  * 再算p2=W1~Wn同时出现且短信是非垃圾短信的概率 * 非垃圾短信的百分比
  * 如果p1是p2的很多倍（比如10倍），我们才确信这条短信是垃圾短信  
  * （Wn出现在短信中且短信是垃圾短信的概率，假设垃圾短信有y个，包含Wn的有x个，那么概率就是x/y）
1. 向量空间(欧几里得距离)：音乐推荐算法
  * 以用户为单位：向量是(歌曲1、歌曲2、……、歌曲n)，距离越近表示两用户口味相近
  * 以歌曲为单位：向量是(用户1、用户2、……、用户m)，距离越近表示歌曲的用户群相近，也即歌曲类别相近
1. B树：每个节点的子节点个数不能小于 m/2 的 m叉树，每个节点都存储数据。
1. B+树：只有叶子节点存储数据，且用双向链表连接。只有单链表为什么不行？
  * 插入节点会变复杂
  * select id from t order by id asc 遍历单链表即可，desc则还需要一次内存倒排。
1. 构建索引常用的数据结构
  * 散列表：增删改查时间复杂度是O(1)，适合做内存KV数据库
  * 红黑树：增删改查时间复杂度是O(logn)，Ext文件系统，对磁盘块的索引就是红黑树
  * B+树：适合构建在磁盘上的索引，树的高度低于红黑树，可以减少磁盘IO的次数
  * 跳表：Redis的有序集合
  * 位图和布隆过滤器：可以作为辅助索引存储在内存，加速数据查找的效率  
1. 并行算法：
  * 并行排序：归并是先分好16个区对应16个线程，最后主线程合并结果。快排是主线程先排好16个区对应16个线程，线程结束后即可。
  * 并行查找：将散列表分成16个，针对性的扩容缩容，查找时并发16个线程查找
  * 并行字符串匹配：将主串切成16个，并发16个线程匹配

#### 实战篇
1. redis的常用数据结构：
  * sds相比char的优点有：[阅读redis代码（一）—— SDS数据结构](https://lynnapan.github.io/2017/07/14/redis_sds/)
    * 获取字符长度的复杂度是O(1)
    * 提供API可以安全的处理字符串
    * 修改N次字符串最多需要N次内存分配
    * 可以保存任何二进制数据，char类型遇到0x00就会终止
  * ziplist、listpack相当于一个双向链表，内存连续，且比定长数组更节约内存，[压缩列表 - Redis 设计与实现](https://redisbook.readthedocs.io/en/latest/compress-datastruct/ziplist.html)
  * ziplist包含头信息(11B)、entry数组\[每个entry包含prevlen(1B~5B)、encoding+length(1B~5B)、content]
  * ziplist的增删改查都是O(n)，缺点是会出现级联更新（例如某entry的长度从<=254变为>254，则nextEntry的prevlen的内存空间也会改变）
  * listpack包含头信息(7B)，entry数据\[每个entry包含encoding(1B~5B)、content、length(1B~5B)]，[Redis 数据结构的设计与实现](https://wingsxdu.com/post/database/redis/struct/)
  * qucklist是一个双向链表，节点是ziplist（每个ziplist不能超过8K）
  * skiplist是zset的基础数据结构，成员对象是sds，成员分值是long
  * dict是hash的基础数据结构，有2个ht，扩容时会用到ht\[1]
  * dict渐进式rehash：
    * rehash时查询操作同时查2个ht，ht\[0]数据都搬移道ht\[1]后，ht\[0]=ht\[1]，ht\[1]=null
    * 每次增删改查操作时，迁移一部分数据，定时任务每次迁移一部分数据
  * zipmap是内存连续的键值对
    * 结构：<zmlen><len>"foo"<len><free>"bar"<len>"hello"<len><free>"world"<end>
    * 实例：\x02\x03foo\x03\x00bar\x05hello\x05\x00world\xff  
    * 虽然查询效率是O(n)，但是在数据量小的时候效率并不差且节约内存
  * intset是set的结构之一，当set元素都是整型且不超过512个就用intset
  * intset用于有序、无重复地保存多个整数值，因为可以二分查找所以效率是O(log n)
  * Hash，单值长度>64或者元素数量>512，用【dict】，否则用【ziplist】。ziplist的entry数组是k1、v1、k2、v2、……
  * List，单值长度>64或者元素数量>512，用【linkedlist】或【quicklist】，否则用【ziplist】。quicklist需要版本>=3.2。
  * Zset，单值长度>64或者元素数量>128，用【skiplist】，否则用【ziplist】。ziplist的entry数组是member1、score1、……
  * Set，元素都是整型或者元素数量<=512，用【intset】，否则用【dict】
1. Disruptor 是java的一个并发编程框架，一个高效的并发内存消息队列
  * 普通的循环队列，为了线程安全，在push和pop的时候需要加锁。
  * Disruptor循环队列，每个生产者(线程)预先申请N个元素空间，然后可以无锁写，因而速度快。消费者同理。
1. 微服务的鉴权、限流：
  * 鉴权之精准匹配：散列表，时间复杂度O(1)
  * 鉴权之前缀匹配：前缀树，时间复杂度O(log n)
  * 鉴权之模糊匹配：数组+回溯算法
  * 限流之固定时间窗口：变量1存时间，变量2存请求量
  * 限流之滑动时间窗口：假设限流1分钟100次，建N=101的循环队列，每次有新请求，先删除超过1分钟的元素，再检查能否push
1. 短网址之ID生成器：
  * 母发号器+N个子发号器，母发号器只批量发号给子发号器，客户端从子发号器取ID
  * N个发号器，例如0号发号器只发尾号为0的，1号发号器只发尾号为1的……