### 《凤凰架构》

#### 参考资料
* [《凤凰架构》在线版](http://icyfenix.cn/)

#### 第一部分，演进中的架构（架构涉及到哪些标准方案）
* 1990提出分布式运算环境，以失败告终
  * 受限于机器的硬件条件，不能做到“如同本地调用一般简单透明的”分布式系统
* 单体系统时代
  * 优点：程序在同一机器同一进程，程序简单高效
  * 缺点1：损失了各个功能模块的自治隔离能力
  * 缺点2：靠希望每一处的代码都尽量可靠、不出错来构建可靠系统
  * （可靠系统是从“追求尽量不出错”到正视“出错是必然”的观念转变）
* SOA时代（Service-Oriented Architecture，面向服务的架构）
  * 三个有代表性的架构：
    * 信息孤岛系统：各个系统完全独立（现实是系统之间需要连接）
    * 微内核架构：一个核心模块和若干插件模块（插件模块之间有时也需要连接）
    * 事件驱动架构：一个事件管道和若干个子系统，每个子系统可以订阅和处理自己感兴趣的事件
  * SOA架构的“更具体”：WSDL发布服务，UDDI注册服务，EBS实现子系统的通讯
  * SOA架构的“更系统”：SOA不仅关心技术，还关注需求、流程、管理
  * SOA架构的缺点1：需要精密的流程和理论，只有专业人员才能驾驭
  * SOA架构的缺点2：很难作为一种广泛普适性的软件架构风格来推广
* 微服务的九个核心特征，以区别SOA：
  * 围绕业务去构建组织：根据康威定律，如果把同一个产品的功能分在两个团队，将造成沟通成本
  * 分散治理：服务归属于哪个团队，哪个团队就要全权负责
  * 通过服务来实现独立自治的组件：对外提供服务而不是类库
  * 产品化思维
  * 数据去中心化：不同的服务使用独立的数据库
  * 强终端弱管道：服务之间的通讯协议要简单，不像SOAP那样复杂
  * 容错性设计：允许服务出错，同时做好容错性设计
  * 演进式架构：服务是可以被替代的，存在不可替代的服务是架构设计的缺陷
  * 基础设施自动化：减少CI/CD的复杂性
* 后微服务时代：解决微服务架构问题，从纯软件层面到软硬件一体
* 无服务时代：后端设施（数据库、消息队列、日志、存储等）和函数

#### 第二部分，架构师的视角（理清分布式系统中新的挑战与应对）
* 访问远程服务
  * 进程间通讯：管道、信号、信号量、消息队列、共享内存、UnixDomainSocket
  * RPC的三个问题：如何表示数据(JSON/Protocol Buffer)、如何传递数据(SOAP/Http)、如何确定方法(WSDL/JSON-WSP)
* RPC经历的几个阶段：
  * W3C Web Service：除了SOAP\WSDL\UDDI外，还有解决事务、一致性、事件、通知的协议。协议太复杂，对开发者是负担
  * 不再最求大而全，分裂的RPC：
    * 朝着面向对象发展
    * 朝着性能发展：gRPC基于Protocol Buffer和Http2、Thrift是自己的序列化和基于TCP协议
    * 朝着简化发展：JSON-RPC
  * 不仅仅负责调用远程服务，还负责管理远程服务(负载均衡、服务注册、可观察性等等)
  * （分布式系统真的需要RPC来调用本地方法吗？其实只要能提供服务就行了）
* REST风格的不足和争议：
  * 登录和注销接口：抽象化一个session资源，登录是put、注销是delete
  * 自定义方法：[Google的REST](https://google-cloud.gitbook.io/api-design-guide/custom_methods)常用自定义方法有cancel/batchGet/move/search/undelete
  * 只查询用户的名称：REST默认返回用户的所有字段，实现此功能可以这样users/12?fields=name
  * 批量给1000个用户名加vip前缀：抽象化一个资源VIP-Modify-Task，然后传1000个用户id
  * 购物下单接口：涉及多个资源(用户、订单、库存、积分)的修改，抽象化一个资源来表示这个流程
* 事务处理之本地事务：靠支持事务的数据源如InnoDB来支持
* 事务处理之分布式事务
  * [分布式系统中的一致性与共识算法](http://www.xuyasong.com/?p=1970)
  * ACID专注于分布式事务；CAP和BASE是分布式通用理论
  * 2PC用于保证多个数据分片上事务的原子性，Paxos协议用于保证同一个数据在多个副本的一致性，两者是互补关系
  * 2PC的协调者可以通过Paxos协议来选出
  * 2PC和TCC
    * 2PC：准备阶段所有节点写redo日志和加锁，提交阶段所有节点commit(协调者第1个commit)
    * TCC(Try-Confirm-Cancel)：对业务有侵入性，在Try阶段对数据做冻结，Cancel阶段对数据做恢复
* 透明多级分流系统
  * [浏览器缓存原理](https://learnku.com/articles/43143)，浏览器先检查Cache-Control/Expire，过期则带上If-None-Match/If-Modified-Since请求服务器
  * 域名解析，有TTL缓存时间
  * 传输链路：H2之前使用雪碧图等等；Gzip压缩；使用H2或者H3
  * 内容分发：域名别名指向CDN厂商的glsb；CDN的主动推送或者被动回源
  * 负载均衡之mac层：三角传输(LB和server使用同一虚拟ip)，需在二层网络
  * 负载均衡之ip层：
    * 方案1：三角传输(LB和server使用同一虚拟ip，使用IP隧道)，非二层网络也行
    * 方案2：NAT模式，LB修改dIP把流量转发给server，server需配置网关地址为LB
    * 方案3：SNAT模式，LB修改dIP把流量转发给server(同时修改sIP为LB自己)，好处是server不需要配置网关，坏处是server看不到真实ip
  * 负载均衡之传输层：同ip层，可以根据传输协议(tcp/udp)转发
  * 负载均衡之应用层：nginx、haproxy
  * 服务器缓存：缓存淘汰策略(lru/lfu)，缓存穿透(db记录不存在)、缓存击穿(缓存过期了)、雪崩(db压力陡增)  
* 架构安全性
  * OAuth2.0授权
    * 授权码模式：需要有自己的应用服务器，与授权服务器交互2次，一次拿授权码，一次拿token
    * 隐式授权模式：不需要有自己的应用服务器，通过授权服务器跳转回的url拿token，例如gtalk
    * 密码模式：用户带用户名密码请求应用服务器，应用服务器带用户名密码请求授权服务器，要求应用服务器、授权服务器属于同一公司
    * 客户端模式：应用服务器直接通过clientId、clientSecret请求授权服务器获得token
  * 凭证：一般用session或者jwt
  * 传输：https
    
#### 第三部分，分布式的基石（解决分布式问题的思路、方法和工具）
* 强一致性共识协议：
  * Paxos：任何节点都可以提案，所以需要解决“活锁”问题
  * Raft：先选主，只有主节点可以提案
* 最终一致性共识协议Gossip：
  * 并不能和Paxos、Raft算法等价，只能说他们达成的目标是一致的
  * 每个节点收到消息后，把消息同步给和它相邻的若干节点
* 服务的三个问题：
  * 服务发现：基于kvdb实现、基于CoreDNS、基于框架如Eureka、Consul
  * 网关路由：五种网络IO模型
  * 客户端负载均衡
* 流量治理之容错策略：故障转移(对调用者透明)、快速失败(调用者控制)、安全失败、沉默失败、故障恢复、并行调用(有一个成功即可)、广播调用(如2PC)
* 流量治理之容错设计模式：断路器模式(超过阈值拒绝服务)、舱壁隔离模式(每个服务对应一个线程池)、重试模式(要有超时和次数限制)
* 流量控制之否决式限流：固定窗口、滑动窗口
* 流量控制之阻塞式限流：漏桶模式(通满就拒绝服务)、令牌桶模式(没有令牌就拒绝服务)
  * [限流:漏桶算法和令牌桶算法](https://maiyang.me/post/2017-05-28-rate-limit-algorithm/)
  * 假设两桶都限流80qps，当出现qps大于80时，对于下游的qps漏桶依然保证是80，而令牌桶可短暂高于80
  * 意味着遇到突发流量，漏桶的请求需要排队(不友好)，而令牌桶不用
* 流量控制之分布式限流：
  * 单机限流适合集群网关处的限流，可以用否决式和阻塞式
  * 分布式限流是控制集群内部服务的：来了一个请求，先从网关处领取X元，访问A服务消耗A元，访问B服务消耗B元，没钱了无法访问服务(或者再找网关要)
* 可靠通讯：从“边界安全”到“零信任网络”
* 可靠通讯服务认证的两种方式：
  * 基于istio：可以配置针对某个namespace的所有流量开启mTLS
  * 基于OAuth2.0的客户端模式：clientSecret通过启动参数传给服务
* istio还提供终端用户认证和授权：
  * [Istio安全架构--理解身份/认证/授权](https://blog.csdn.net/gengzhikui1992/article/details/115529831)
  * [使用 Istio 进行 JWT 身份验证（充当 API 网关）](https://ryan4yin.space/posts/use-istio-for-jwt-auth/)
* 可观察性：日志、追踪、聚合

#### 第四部分，不可变基础设施（如何隐藏技术细节使其不会干扰业务）
* linux的进程隔离(七种)：
  * Mount：隔离文件系统，chroot命令
  * UTS：隔离主机的hostname
  * IPC：隔离进程间通讯的渠道
  * PID：无法看到其他namespace的进程
  * Network：隔离网络，如网卡、网络栈、ip、端口等
  * User：隔离用户和用户组
  * Time：支持进程独立设置系统时间
* linux的资源隔离：cgroups，隔离cpu、内存、块设备、其他设备、网卡
* linux网络虚拟化：
  * 内核控制了四层，提供socket接口给应用层
  * netfilter框架的5个hook，iptables工具基于框架提供5个表
  * 虚拟网络设备之tun/tap：tun相当于三层，tap相当于二层
    * 物理网卡一端是物理网卡，一端是网络协议栈；虚拟网卡一端是用户态程序，一端是网络协议栈
    * vpn程序就是利用的tun/tap
  * 虚拟网络设备之veth pair：两个docker容器如果使用veth pair连接，不需要反复进入协议栈
  * 虚拟网络设备之linux bridge：其实就一个虚拟交换机，bridge可以设置ip地址
    * 比普通交换机多一个功能，当bridge接收的数据包mac和ip均是自己，即表示和宿主机通讯
  * 虚拟网络之VXLAN：linux3.7支持
    * 普通数据包=mac头+原始二层内容，VXLAN数据包=outer数据包(udp+vxlan)+原始二层内容
  * 虚拟网络之MACVLAN：一个网卡可以设置多个ip、多个mac
  * 容器间通讯：
    * 开箱即用的方案：bridge、host、none
    * 用户自定义方案：container、MACVLAN、overlay(即VXLAN)
* 容器网络接口：docker提出的CNM落败，google提出的CNI胜出
* 容器网络插件：
  * Overlay模式：Flannel的VXLAN，Calico的IPIP
  * 路由模式：Flannel的hostGW，Calico的BGP
  * Underlay模式：MACVLAN、SR-IOV。
    * 依赖硬件和底层网络环境，难以做到像Overlay那样开箱即用
* 静态存储分配：运维预置好pv，开发声明pvc，k8s进行匹配
* 动态存储分配：运维预置好sc，开发声明pvc和关联的sc，k8s通过sc生成pv再和pvc绑定
* 容器存储接口：FlexVolume已经废弃，CSI胜出
* 容器存储插件：从in-tree到out-tree
* 资源与调度：
  * 资源模型：一切皆为资源是声明式API的必要前提，资源分为物理资源(cpu、内存、存储)和抽象资源
  * 服务质量和优先级：
    * Guaranteed：requests=limits、
    * BurstAble：requests<limits或者只设置了其中1个
    * BestEffort：没有设置requests和limits
  * 默认调度器：
    * 调度器并不会直接与kubelet通讯来创建Pod，而是间接借助etcd
    * 这些Informer持续监视etcd中它关心的资源变化，一旦发生变化，就更新调度队列
    * Scheduler从调度队列中取任务并执行
* istio代理注入：对namespace设置了istio-injection=enabled标签的pod注入sidecar
* istio流量劫持：
  * [Service Mesh中的iptables流量劫持](https://www.ciocso.com/article/730.html)
  * [istio学习笔记 - 1 （初探数据平面）](https://blog.csdn.net/weixin_43490818/article/details/89314360)
  * [Istio中的透明代理问题](https://blog.gmem.cc/istio-tproxy)
  * Istio对入站流量的两种拦截模式：REDIRECT(envoy和应用看到的都是127.0.0.1)、TPROXY(envoy能看到真实ip，应用看到的是127.0.0.1)
* istio可靠通讯：把代理转发的行为规则抽象成三种资源：Listener、Cluster、Router
* 服务网格之数据平面：都是CNCF成员：envoy、Linkerd 2、MOSN(蚂蚁金服)
* 服务网格之控制平面：微软的OSM(使用envoy)，谷歌的istio(没有加入CNCF)

#### 第五部分，技术方法论（软件开发过程中的一些经验）
* 选择微服务的驱动力：
  * 需要支持多种异构语言
  * 技术专家带领大量普通开发者，使用微服务保证局部的容错、自愈与快速迭代
  * 来自甲方的约束
  * 快速发展的新业务，微服务可以保证快速迭代
  * 历史包袱沉重的大项目，借助微服务进行拆分
* 使用微服务的前提条件：
  * 根据康威定律的“系统的架构趋同于组织的沟通结构”，先要做好政治工作
  * 组织中需要有微服务的技术专家
  * 微服务化的目标是构建具有自治、自愈能力的基础设施生态
  * 简单系统使用单体架构，复杂系统则用微服务
* 微服务的粒度：
  * 一个微服务最少要有完备的CI/CD流程，且业务是完整和内聚的。
  * 两个披萨原则：团队6~10人
* 系统复杂型两个来源：
  * 认知负荷：蚂蚁族群和国家的人口可能一样多，但是治理国家更困难
  * 协作成本：完成任务需要的沟通成本、管理成本
* 微服务的认知负荷较高，但是协作成本较低（对比单体系统，服务只依赖它需要的服务）。

