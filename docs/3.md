### 高性能MySQL

#### 表空间
* 表空间：1个表对应1个表空间
* 段：好比一个师，1个索引有2个段（叶子节点段、非叶子节点段），开始表只有2个段，每加1个索引增加2个段，对应的描述是INODE Entry
* 区：好比一个团，1个区有64个物理连续的页，1MB，对应的描述是XDES Entry
* 碎片区：好比一个独立团，处于FREE、FREE_FRAG、FULL_FRAG状态的区直属于表空间
* 注意点1：如果给每个新表都分配一个区(1MB)太浪费，所以开始的数据页先放在公共的碎片区，当表有32个数据页后，开始分配一个区
* 注意点2：表空间默认只有1个INODE类型的页(最多85个INODE Entry)，不够可以新建，并由SEG_INODES_FULL链表、SEG_INODES_FREE链表维护
* 注意点3：每个段需要维护3个链表，它们的基节点信息在INODE Entry，每个表空间也维护3个链表，它们的基节点信息在File Space Header

#### 独立表空间extent0前3页是固定的
* FSP_HDR：存储256个XDES Entry和File Space Header
* IBUF_BITMAP：Change Buffer
* INODE：存储INODE Entry List

#### 独立表空间extent0第0页的File Space Header
* 表空间的ID
* FREE链表的基节点
* FREE_FRAG链表的基节点
* FULL_FRAG链表的基节点
* Next Unused Segment ID：表空间创建新的段时取值并自增

#### 独立表空间extent256、extent512...前2页是固定的
* XDES：存储256个XDES Entry
* IBUF_BITMAP：Change Buffer

#### 系统表空间extent0前8页是固定的
* FSP_HDR
* IBUF_BITMAP
* INODE
* Insert Buffer Header	存储Insert Buffer的头部信息
* Insert Buffer Root	存储Insert Buffer的根页面
* Transaction System	事务系统的相关信息
* First Rollback Segment	第一个回滚段的页面
* Data Dictionary Header	数据字典头部信息

#### 系统表空间extent0的Data Dictionary Header页
* Max Row ID：隐式row_id列的ID，所有库所有表共享。
* Max Table ID：表的ID，所有库所有表共享。
* Max Index ID：索引的ID，所有库所有表共享。
* Max Space ID：表空间的ID，所有库所有表共享。
* Root of SYS_TABLES clust index：本字段代表SYS_TABLES表聚簇索引的根页面的页号。
* Root of SYS_TABLE_IDS sec index：本字段代表SYS_TABLES表为ID列建立的二级索引的根页面的页号。
* Root of SYS_COLUMNS clust index：本字段代表SYS_COLUMNS表聚簇索引的根页面的页号。
* Root of SYS_INDEXES clust index本字段代表SYS_INDEXES表聚簇索引的根页面的页号。
* Root of SYS_FIELDS clust index：本字段代表SYS_FIELDS表聚簇索引的根页面的页号。

#### EXPLAIN分析的type列
* const：通过主键或者唯一索引等值查询（唯一索引可以有多个null值，所以查null值不算）
* ref：通过普通索引等值查询，或者唯一索引查null值
* ref_or_null：where key1='a' or key1 is null。null值都在索引的最左边。
* range：in查询，><查询，like前缀查询
* index：不能用索引，但是可以用覆盖索引
* all：全表扫描
* index_merge：如果2个索引各自取到的索引记录是按照主键排序的，则同时使用这2个索引：
  * 取交集：where key1='1' and key3='3'
  * 取并集：where key1='1' or key3='3'
  * 先排序再取并集：where key1<'1' or key3>'3'（虽然各自的记录不是按照主键排序，但是记录数不多）

