### MySQL是怎样运行的

#### 表空间
* 表空间：1个表对应1个表空间
* 段：好比一个师，1个索引有2个段（叶子节点段、非叶子节点段），开始表只有2个段，每加1个索引增加2个段，对应的描述是INODE Entry
* 区：好比一个团，1个区有64个物理连续的页，1MB，对应的描述是XDES Entry
* 碎片区：好比一个独立团，处于FREE、FREE_FRAG、FULL_FRAG状态的区直属于表空间
* 注意点1：如果给每个新表都分配一个区(1MB)太浪费，所以开始的数据页先放在公共的碎片区，当表有32个数据页后，开始分配一个区
* 注意点2：表空间默认只有1个INODE类型的页(最多85个INODE Entry)，不够可以新建，并由SEG_INODES_FULL链表、SEG_INODES_FREE链表维护
* 注意点3：每个段需要维护3个链表，它们的基节点信息在INODE Entry，每个表空间也维护3个链表，它们的基节点信息在File Space Header

#### 独立表空间extent0前3页是固定的
* FSP_HDR：存储256个XDES Entry和File Space Header
* IBUF_BITMAP：Change Buffer
* INODE：存储INODE Entry List

#### 独立表空间extent0第0页的File Space Header
* 表空间的ID
* FREE链表的基节点
* FREE_FRAG链表的基节点
* FULL_FRAG链表的基节点
* Next Unused Segment ID：表空间创建新的段时取值并自增

#### 独立表空间extent256、extent512...前2页是固定的
* XDES：存储256个XDES Entry
* IBUF_BITMAP：Change Buffer

#### 系统表空间extent0前8页是固定的
* FSP_HDR
* IBUF_BITMAP
* INODE
* Insert Buffer Header	存储Insert Buffer的头部信息
* Insert Buffer Root	存储Insert Buffer的根页面
* Transaction System	事务系统的相关信息
* First Rollback Segment	第一个回滚段的页面
* Data Dictionary Header	数据字典头部信息

#### 系统表空间extent0的Data Dictionary Header页
* Max Row ID：隐式row_id列的ID，所有库所有表共享。
* Max Table ID：表的ID，所有库所有表共享。
* Max Index ID：索引的ID，所有库所有表共享。
* Max Space ID：表空间的ID，所有库所有表共享。
* Root of SYS_TABLES clust index：本字段代表SYS_TABLES表聚簇索引的根页面的页号。
* Root of SYS_TABLE_IDS sec index：本字段代表SYS_TABLES表为ID列建立的二级索引的根页面的页号。
* Root of SYS_COLUMNS clust index：本字段代表SYS_COLUMNS表聚簇索引的根页面的页号。
* Root of SYS_INDEXES clust index本字段代表SYS_INDEXES表聚簇索引的根页面的页号。
* Root of SYS_FIELDS clust index：本字段代表SYS_FIELDS表聚簇索引的根页面的页号。

#### EXPLAIN分析的type列
* const：通过主键或者唯一索引等值查询（唯一索引可以有多个null值，所以查null值不算）
* ref：通过普通索引等值查询，或者唯一索引查null值
* ref_or_null：where key1='a' or key1 is null。null值都在索引的最左边。
* range：in查询，><查询，like前缀查询
* index：不能用索引，但是可以用覆盖索引
* all：全表扫描
* index_merge：如果2个索引各自取到的索引记录是按照主键排序的，则同时使用这2个索引：
  * 取交集：where key1='1' and key3='3'
  * 取并集：where key1='1' or key3='3'
  * 先排序再取并集：where key1<'1' or key3>'3'（虽然各自的记录不是按照主键排序，但是记录数不多）

#### 两表连接
* 内连接：from t1, t2 或 from t1 inner join t2。where 条件会过滤记录
* 左连接：from t1 left join t2 ON ... WHERE ...。where 条件会过滤记录，ON 条件不符合的记录仍然展示。
* 右连接：from t1 left join t2 ON ... WHERE ...。where 条件会过滤记录，ON 条件不符合的记录仍然展示。
* 驱动表的EXPLAIN分析和上文描述一致
* 被驱动表EXPLAIN分析的type列：
  * eq_ref：通过主键或者不能为null的唯一索引
  * ref：通过普通索引等值查询，或者可以为null的唯一索引
  * ref_or_null：where key1='a' or key1 is null。null值都在索引的最左边。
  * range：in查询，><查询，like前缀查询
  * index：不能用索引，但是可以用覆盖索引
  * all：全表扫描
* 从驱动表查到的结果集先放到Join Buffer内(默认256K)，然后再到被驱动表查询

#### 第12章 执行计划的成本计算
* 成本计算依赖的数据：
  * 读取1个页面的成本是1
  * 读取1条记录并检测是否满足条件的成本是0.2
  * table信息：Rows表示记录数，Data_length表示聚簇索引占用的字节
  * index信息：Cardinality表示不重复的记录数
* IN查询估算记录数：
  * eq_range_index_dive_limit限制内：使用index dive，基于索引来计算
  * eq_range_index_dive_limit限制外：使用index信息，IN查询的每个元素对应的记录数 = Rows / Cardinality
* 步骤1：找出所有可能使用的索引
* 步骤2：计算全表扫描的代价
  * I/O成本：Data_length / 16KB * 1
  * CPU成本：Rows * 0.2
* 步骤3：计算使用索引uk_key2的代价
  * 访问二级索引I/O成本：因为只有一个扫描区间，所以是1
  * 访问二级索引CPU成本：根据扫描区间的边界估算出记录数=95，所以是95 * 0.2
  * 访问聚簇索引I/O成本：每次回表都算读取1个页面，所以是95 * 1
  * 访问聚簇索引CPU成本：95 * 0.2
* 步骤4：计算使用索引idx_key1的代价
  * 访问二级索引I/O成本：因为有三个单点区间，所以是3
  * 访问二级索引CPU成本：估算出记录数=118，所以是118 * 0.2
  * 访问聚簇索引I/O成本：118 * 1
  * 访问聚簇索引CPU成本：118 * 0.2
* 步骤5：选出代价最低的方案

#### 第13章 InnoDB的统计数据
* mysql.innodb_table_stats：n_rows总记录数、cluster_index_size聚簇索引页面数、sum_of_other_index_sizes其他索引页面数
  * 统计碎片区的页面数：INODE Entry存储有对应的页号
  * 统计叶子节点段和非叶子节点段的页面数：INODE Entry存储有FREE、NOT_FULL、FULL链表的基节点，据此计算页面数
* mysql.innodb_index_stats：size索引页面数、n_leaf_pages叶子节点页面数、n_diff_pfxxx不重复的记录数
* 统计数据如何更新：开启了自动更新后，数据每增长10%就算一次，根据配置的采样数采样统计
* 统计数据可以保存在内存或者磁盘，新版本都是在磁盘
* innodb_stats_method配置：计算不重复的记录数时，每个null值都是重复值、每个null值都不同、忽略null值

#### 第14章 子查询优化
* 子查询一般会出现在3个位置：
  * select子句：select (select m2 from t2 limit 1)
  * from子句：from (select m2 from t2) as tt
  * on/where子句
* 子查询按照返回的结果分类：
  * 标量子查询：where m1 = (select m2 from t2 limit 1)
  * 行子查询：where (m1, n1) = (select m2, n2 from t2 limit 1)
  * 列子查询：where m1 in (select m2 from t2)
  * 表子查询：where (m1, n1) = (select m2, n2 from t2)
* 子查询按照与外层查询的关系分类：
  * 不相关子查询：不依赖外层查询的值，上述SQL都是
  * 相关子查询：where t1.m1 in (select t2.m2 from t2 where t2.n2 = t1.n1)
* 能转换成半连接的IN查询的条件：
  * 不能是NOT IN
  * 外层查询的其他搜索条件必须是AND，不能是OR
  * 子查询必须是单一的查询，不能是由UNION连接起来的查询
  * 子查询不能包含GROUP BY、HAVING语句或者聚集函数如MAX/MIN/COUNT/AVG/SUM
* IN查询的查询策略：
  * 能转换成半连接的IN查询则按半连接的5种查询策略估算成本
  * 能转换成EXISTS查询则先转换，转换成EXISTS也许能用到索引：
    * 原始的：where key1 in (select key3 from s2 where common_field='a') or key2 > 1
    * 转换后：where exists (select 1 from s2 where s2.common_field='a' and s2.key3=s1.key1) or key2 > 1
    * 转换后的子查询，可以用到s2.key3的索引
  * 都不能，则先把子查询变成物化表，再进行连接查询
    * 子查询是不相关子查询：物化后子查询只执行一遍
    * 子查询是相关子查询：物化后子查询可能执行多遍
* IN查询原始SQL：select * from s1 where xxx in (select key1 from s2 where s2.xxx)
* IN查询半连接：select s1.* from s1 JOIN s2 ON s1.xxx = s2.key1 where s2.xxx 
* IN查询半连接的5种查询策略，估算并选择成本最低的策略执行查询：
  * Table Pollout：上述转换成半连接的SQL，如果s2.key1是主键或者唯一索引，则按内连接来查询即可
  * Duplicate Weedout：如果s2.key1不是主键或者唯一索引，在回表之前，还需要对主键记录去重
  * LooseScan：s2是驱动表并且s2正好用到了key1这个普通索引，可以在索引上跳过重复的key1值，再去被驱动表查询
  * Semi-join Materialization：先把子查询变成物化表，再进行连接查询
  * FirstMatch：对于关联子查询，依次取外层查询的一条记录，到子查询里FirstMatch，匹配到则放入结果集

#### 第15章 EXPLAIN详解

```
create table s1 like single_table;
create table s2 like single_table;
DELIMITER //
create procedure insert_table(in max int(10))
begin
declare i int default 0;
repeat
set i=i+1;
insert into s1 values(NULL,i%100,i,i%10,i,MD5(i),RAND(),i);
insert into s2 values(NULL,i%100,i,i%10,i,MD5(i),RAND(),i);
insert into single_table values(NULL,i%100,i,i%10,i,MD5(i),RAND(),i);
until i=max end repeat;
end;
call insert_table(5000);
//

1. select_type: 
* SIMPLE: EXPLAIN SELECT * FROM s1 INNER JOIN s2; // 不包含union或者子查询
* PRIMARY: EXPLAIN SELECT * FROM s1 UNION SELECT * FROM s2; // 包含union，最左边的table
* UNION: EXPLAIN SELECT * FROM s1 UNION SELECT * FROM s2; // 包含union，除了最左边的table，其他都是UNION
* UNION RESULT: EXPLAIN SELECT * FROM s1 UNION SELECT * FROM s2; // 使用了临时表来完成去重
* SUBQUERY: EXPLAIN SELECT * FROM s1 WHERE key1 IN (SELECT key1 FROM s2) OR key3 = 'a'; // 子查询不能转成半连接&&决定采用子查询物化的方案
* DEPENDENT SUBQUERY: EXPLAIN SELECT * FROM s1 WHERE key1 IN (SELECT key1 FROM s2 WHERE s1.key2 = s2.key2) OR key3 = 'a'; // 子查询不能转成半连接&&决定采用子查询物化的方案
* DERIVED: EXPLAIN SELECT * FROM (select count(*) from s1 group by key1) as s; // 包含派生表，决定采用派生表物化的方案
* MATERIALIZED : EXPLAIN SELECT * FROM s1 WHERE key1 IN (SELECT key1 FROM s2); // 包含子查询，决定采用子查询物化的方案

2. type
* const: EXPLAIN SELECT * FROM s1 WHERE id = 5; // 主键或者唯一索引
* eq_ref: EXPLAIN SELECT * FROM s1 INNER JOIN s2 ON s1.id = s2.id; // 连接查询、主键或者不为null的唯一索引
* ref: EXPLAIN SELECT * FROM s1 WHERE key1 = 'a'; // 普通索引
* ref_or_null: EXPLAIN SELECT * FROM s1 WHERE key1 = 'a' OR key1 IS NULL;
* index_merge: EXPLAIN SELECT * FROM s1 WHERE key1 = 'a' OR key3 = 'a'; // 索引合并
* unique_subquery: EXPLAIN SELECT * FROM s1 WHERE key2 IN (SELECT id FROM s2 where s1.key1 = s2.key1) OR key3 = 'a'; // IN查询转EXISTS，可用主键或者不为null的唯一索引
* index_subquery: EXPLAIN SELECT * FROM s1 WHERE key2 IN (SELECT key3 FROM s2 where s1.key1 = s2.key1) OR key3 = 'a'; // IN查询转EXISTS，可用普通索引
* range: EXPLAIN SELECT * FROM s1 WHERE key1 IN ('a', 'b', 'c');
* index: EXPLAIN SELECT key_part2 FROM s1 WHERE key_part3 = 'a'; // 覆盖索引，但是需要扫描全部索引
* all: EXPLAIN SELECT * FROM s1; // 全表扫描

3. key_len:
* int4字节、bigint8字节
* char和varchar：假设字符数是n，utf8就是3n，utf8mb4就是4n；允许null值就是3n+1；变长类型就是3n+2

4. ref(type属于const/eq_ref/ref/ref_or_null/unique_subquery/index_subquery时)
* const: EXPLAIN SELECT * FROM s1 WHERE key1 = 'a';
* s1.id: EXPLAIN SELECT * FROM s1 INNER JOIN s2 ON s2.id = s1.id;
* func: EXPLAIN SELECT * FROM s1 INNER JOIN s2 ON s2.key1 = UPPER(s1.key1);

5. rows(全表扫描或者扫描索引，扫描的行数)
* EXPLAIN SELECT * FROM s1 WHERE key1 > 'z'; // 满足key1 > 'z'的条数有266

6. filtered
* EXPLAIN SELECT * FROM s1 WHERE key1 > 'z' AND common_field = 'a'; // 266条记录有filtered%比例的记录满足common_field = 'a'
* EXPLAIN SELECT * FROM s1 INNER JOIN s2 ON s1.key1 = s2.key1 WHERE s1.common_field = 'a'; // 驱动表s1的rows=9688，filtered=10，说明被驱动表要查询约968次

7. Extra
* No tables used: EXPLAIN SELECT 1;
* Impossible WHERE: EXPLAIN SELECT * FROM s1 WHERE 1 != 1;
* No matching min/max row: EXPLAIN SELECT MIN(key1) FROM s1 WHERE key1 = 'abcdefg';
* Using index: EXPLAIN SELECT key1 FROM s1 WHERE key1 = 'a'; // 可用使用覆盖索引
* Using index condition: EXPLAIN SELECT * FROM s1 WHERE key1 > 'z' AND key1 LIKE '%a'; // 使用了索引下推
* Using where: 当搜索条件需要在Server层判断时
* Using join buffer (Block Nested Loop): EXPLAIN SELECT * FROM s1 INNER JOIN s2 ON s1.common_field = s2.common_field; // 不能用索引访问被驱动表时，利用Join Buffer提速
* Using intersect: EXPLAIN SELECT * FROM s1 WHERE key1 = '1' AND key3 = '1';
* Using union: EXPLAIN SELECT * FROM s1 WHERE key1 = '1' OR key3 = '1';
* Using sort_union: EXPLAIN SELECT * FROM s1 WHERE key1 < '1' OR key3 > '99'; // 先把主键排序再合并，再回表
* Using filesort: order by语句不能用到索引时，使用内存排序或者硬盘排序
* Using temporary: 包含DISTINCT、GROUP BY、UNION的子查询，需要借助临时表完成去重、排序等等
* Start temporary, End temporary: explain select * from s1 where key2 in (select key1 from s2 where key3 > '1'); // 半连接策略2，需要临时表来去重
* LooseScan: 半连接策略3
* FirstMatc: EXPLAIN SELECT * FROM s1 WHERE common_field IN (SELECT key1 FROM s2 where s1.key3 = s2.key3); // 半连接策略5
```

#### 第16章 使用optimizer trace查询优化器具体工作
* SET optimizer_trace="enabled=on";
* 执行SQL
* SELECT * FROM information_schema.OPTIMIZER_TRACE;
* 单表查询优化器具体工作：
  * steps\[4].rows_estimation.\[0].range_analysis.table_scan：全表扫描的成本
  * steps\[4].rows_estimation.\[0].range_analysis.potential_range_indexes：可能使用到的索引
  * steps\[4].rows_estimation.\[0].range_analysis.analyzing_range_alternatives：可能使用到的索引的成本
  * steps\[4].rows_estimation.\[0].range_analysis.chosen_range_access_summary：最优方案总结
  
#### 第17章 InnoDB的Buffer Pool
* show VARIABLES like 'innodb_buffer_pool_%'
  * innodb_buffer_pool_size：Buffer Pool的总大小
  * innodb_buffer_pool_instances：Buffer Pool的实例数
  * innodb_buffer_pool_chunk_size：Buffer Pool的每个实例下每个chunk的大小
* Buffer Pool在Mysql启动时已经申请好了，用于缓存从硬盘读到的页：
  * free链表，管理Buffer Pool未使用的页
  * flush链表，管理Buffer Pool已使用的、被修改的页
  * lru链表，主要用于淘汰已使用的、但是最近最少使用的页



















