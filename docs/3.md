### MySQL是怎样运行的

#### 表空间
* 表空间：1个表对应1个表空间
* 段：好比一个师，1个索引有2个段（叶子节点段、非叶子节点段），开始表只有2个段，每加1个索引增加2个段，对应的描述是INODE Entry
* 区：好比一个团，1个区有64个物理连续的页，1MB，对应的描述是XDES Entry
* 碎片区：好比一个独立团，处于FREE、FREE_FRAG、FULL_FRAG状态的区直属于表空间
* 注意点1：如果给每个新表都分配一个区(1MB)太浪费，所以开始的数据页先放在公共的碎片区，当表有32个数据页后，开始分配一个区
* 注意点2：表空间默认只有1个INODE类型的页(最多85个INODE Entry)，不够可以新建，并由SEG_INODES_FULL链表、SEG_INODES_FREE链表维护
* 注意点3：每个段需要维护3个链表，它们的基节点信息在INODE Entry，每个表空间也维护3个链表，它们的基节点信息在File Space Header

#### 独立表空间extent0前3页是固定的
* FSP_HDR：存储256个XDES Entry和File Space Header
* IBUF_BITMAP：Change Buffer
* INODE：存储INODE Entry List

#### 独立表空间extent0第0页的File Space Header
* 表空间的ID
* FREE链表的基节点
* FREE_FRAG链表的基节点
* FULL_FRAG链表的基节点
* Next Unused Segment ID：表空间创建新的段时取值并自增

#### 独立表空间extent256、extent512...前2页是固定的
* XDES：存储256个XDES Entry
* IBUF_BITMAP：Change Buffer

#### 系统表空间extent0前8页是固定的
* FSP_HDR
* IBUF_BITMAP
* INODE
* Insert Buffer Header	存储Insert Buffer的头部信息
* Insert Buffer Root	存储Insert Buffer的根页面
* Transaction System	事务系统的相关信息
* First Rollback Segment	第一个回滚段的页面
* Data Dictionary Header	数据字典头部信息

#### 系统表空间extent0的Data Dictionary Header页
* Max Row ID：隐式row_id列的ID，所有库所有表共享。
* Max Table ID：表的ID，所有库所有表共享。
* Max Index ID：索引的ID，所有库所有表共享。
* Max Space ID：表空间的ID，所有库所有表共享。
* Root of SYS_TABLES clust index：本字段代表SYS_TABLES表聚簇索引的根页面的页号。
* Root of SYS_TABLE_IDS sec index：本字段代表SYS_TABLES表为ID列建立的二级索引的根页面的页号。
* Root of SYS_COLUMNS clust index：本字段代表SYS_COLUMNS表聚簇索引的根页面的页号。
* Root of SYS_INDEXES clust index本字段代表SYS_INDEXES表聚簇索引的根页面的页号。
* Root of SYS_FIELDS clust index：本字段代表SYS_FIELDS表聚簇索引的根页面的页号。

#### EXPLAIN分析的type列
* const：通过主键或者唯一索引等值查询（唯一索引可以有多个null值，所以查null值不算）
* ref：通过普通索引等值查询，或者唯一索引查null值
* ref_or_null：where key1='a' or key1 is null。null值都在索引的最左边。
* range：in查询，><查询，like前缀查询
* index：不能用索引，但是可以用覆盖索引
* all：全表扫描
* index_merge：如果2个索引各自取到的索引记录是按照主键排序的，则同时使用这2个索引：
  * 取交集：where key1='1' and key3='3'
  * 取并集：where key1='1' or key3='3'
  * 先排序再取并集：where key1<'1' or key3>'3'（虽然各自的记录不是按照主键排序，但是记录数不多）

#### 两表连接
* 内连接：from t1, t2 或 from t1 inner join t2。where 条件会过滤记录
* 左连接：from t1 left join t2 ON ... WHERE ...。where 条件会过滤记录，ON 条件不符合的记录仍然展示。
* 右连接：from t1 left join t2 ON ... WHERE ...。where 条件会过滤记录，ON 条件不符合的记录仍然展示。
* 驱动表的EXPLAIN分析和上文描述一致
* 被驱动表EXPLAIN分析的type列：
  * eq_ref：通过主键或者不能为null的唯一索引
  * ref：通过普通索引等值查询，或者可以为null的唯一索引
  * ref_or_null：where key1='a' or key1 is null。null值都在索引的最左边。
  * range：in查询，><查询，like前缀查询
  * index：不能用索引，但是可以用覆盖索引
  * all：全表扫描
* 从驱动表查到的结果集先放到Join Buffer内(默认256K)，然后再到被驱动表查询

#### 第12章 执行计划的成本计算
* 成本计算依赖的数据：
  * 读取1个页面的成本是1
  * 读取1条记录并检测是否满足条件的成本是0.2
  * table信息：Rows表示记录数，Data_length表示聚簇索引占用的字节
  * index信息：Cardinality表示不重复的记录数
* IN查询估算记录数：
  * eq_range_index_dive_limit限制内：使用index dive，基于索引来计算
  * eq_range_index_dive_limit限制外：使用index信息，IN查询的每个元素对应的记录数 = Rows / Cardinality
* 步骤1：找出所有可能使用的索引
* 步骤2：计算全表扫描的代价
  * I/O成本：Data_length / 16KB * 1
  * CPU成本：Rows * 0.2
* 步骤3：计算使用索引uk_key2的代价
  * 访问二级索引I/O成本：因为只有一个扫描区间，所以是1
  * 访问二级索引CPU成本：根据扫描区间的边界估算出记录数=95，所以是95 * 0.2
  * 访问聚簇索引I/O成本：每次回表都算读取1个页面，所以是95 * 1
  * 访问聚簇索引CPU成本：95 * 0.2
* 步骤4：计算使用索引idx_key1的代价
  * 访问二级索引I/O成本：因为有三个单点区间，所以是3
  * 访问二级索引CPU成本：估算出记录数=118，所以是118 * 0.2
  * 访问聚簇索引I/O成本：118 * 1
  * 访问聚簇索引CPU成本：118 * 0.2
* 步骤5：选出代价最低的方案

#### 第13章 InnoDB的统计数据
* mysql.innodb_table_stats：n_rows总记录数、cluster_index_size聚簇索引页面数、sum_of_other_index_sizes其他索引页面数
  * 统计碎片区的页面数：INODE Entry存储有对应的页号
  * 统计叶子节点段和非叶子节点段的页面数：INODE Entry存储有FREE、NOT_FULL、FULL链表的基节点，据此计算页面数
* mysql.innodb_index_stats：size索引页面数、n_leaf_pages叶子节点页面数、n_diff_pfxxx不重复的记录数
* 统计数据如何更新：开启了自动更新后，数据每增长10%就算一次，根据配置的采样数采样统计
* 统计数据可以保存在内存或者磁盘，新版本都是在磁盘
* innodb_stats_method配置：计算不重复的记录数时，每个null值都是重复值、每个null值都不同、忽略null值

#### 第14章 子查询优化
* 子查询按照返回的结果分类：
  * 标量子查询：where m1 = (select m2 from t2 limit 1)
  * 行子查询：where (m1, n1) = (select m2, n2 from t2 limit 1)
  * 列子查询：where m1 in (select m2 from t2)
  * 表子查询：where (m1, n1) = (select m2, n2 from t2)
* 子查询按照与外层查询的关系分类：
  * 不相关子查询：不依赖外层查询的值，上述SQL都是
  * 相关子查询：where t1.m1 in (select t2.m2 from t2 where t2.n2 = t1.n1)
* IN查询原始SQL：select * from s1 where xxx in (select key1 from s2 where s2.xxx)
* IN查询半连接：select s1.* from s1 JOIN s2 ON s1.xxx = s2.key1 where s2.xxx 
* IN查询半连接有5种查询策略，通过计算成本选择成本最低的策略执行查询：
  * Table Pollout：上述转换成半连接的SQL，如果s2.key1是主键或者唯一索引，则按内连接来查询即可
  * Duplicate Weedout：如果s2.key1不是主键或者唯一索引，在回表之前，还需要对主键记录去重
  * LooseScan：s2是驱动表并且s2正好用到了key1这个普通索引，可以在索引上跳过重复的key1值，再去被驱动表查询
  * Semi-join Materialization：先把子查询变成物化表，再进行连接查询
  * FirstMatch：对于关联子查询，依次取外层查询的一条记录，到子查询里FirstMatch，匹配到则放入结果集
* IN查询若不能转换成半连接，也有2种查询策略：
  * 先把子查询变成物化表，再进行连接查询
  * 把IN查询转换成EXISTS查询





















