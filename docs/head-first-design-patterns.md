### Head First设计模式

#### 重写、重载、面向对象四大特性
1. [Java基础之多态的实现重载 vs 重写](https://www.jianshu.com/p/e838c4636a57)
1. 重写（override）：参数和返回值都必须和父类相同
1. 重载（overload）：参数必须不同，返回值可以相同
1. 面向对象四大特性：
  * 封装
  * 抽象
  * 继承：子类使用父类的方法
  * 多态：父类使用子类的方法（重写）
1. UML的六个箭头，[参考1](https://www.cnblogs.com/ylq1990/p/8473041.html)，[参考2](https://www.cnblogs.com/duanxz/archive/2012/06/13/2547801.html)
  * 实现：虚线空心三角；接口实现
  * 泛化：实线空心三角；继承
  * 依赖：虚线箭头；人--->车；人的方法传参需要车这个对象
  * 关联：实线箭头；唐僧——>徒弟；唐僧有个属性关联了徒弟这个对象
  * 聚合：实线空心菱形；has-a
  * 组合：实线实心菱形；contains-a；人没了，四肢也不存在了
1. 15个常用设计模式的分类：
  * 创建型：单例模式、简单工厂、工厂方法、抽象工厂
  * 结构型：装饰者模式、适配器模式、外观模式、组合模式、代理模式
  * 行为型：策略模式、观察者模式、命令模式、模板方法、迭代器模式、状态模式
1. [23种设计模式 - CSDN](https://blog.csdn.net/beijiguangyong/article/details/6010756)

#### 七个设计原则
* [《Head First 设计模式》读书笔记](https://www.qcrao.com/2020/05/10/head-first-design-pattern-reading-notes/)
* 设计原则一：封装变化。找出应用中可能需要变化之处，把它们独立出来，不要和那些不需要变化的代码混在一起。如策略模式。
* 设计原则二：针对接口编程，而不是针对实现编程。
* 设计原则三：多用组合，少用继承。如观察者模式。
* 设计原则四：为了交互对象之间的松耦合设计而努力。
* 设计原则五：类应该对扩展开放，对修改关闭。
* 设计原则六：依赖倒置原则。要依赖抽象，不要依赖具体类。
* 设计原则七：最少知识原则。只和你的密友谈话。如外观模式。

#### 策略模式
1. 案例：鸭有绿头鸭、红头鸭、橡皮鸭；鸭的特性有飞、叫
1. 坏的设计1：基类有鸭（包含方法fly、quack），橡皮鸭继承基类（重写方法fly、quack）
1. 坏的设计2：基类有鸭，接口有Flyable、Quackable，子类通过setFlyBehavior、setQuackBehavior来实现飞、叫
1. 好的设计：
  * 基类有鸭（包含方法fly、quack，包含属性flyBehavior、quackBehavior）
  * 每个子类都继承基类（构造函数赋值不同的flyBehavior、quackBehavior）
1. oo原则：
  * 封装变化
  * 多用组合，少用继承
  * 针对接口编程，不针对实现编程
1. oo模式：策略之间可以相互替换，让策略的变化独立于使用策略的客户

#### 观察者模式
1. 案例：主题有温度、湿度、气压；显示屏有三个
1. 坏的设计：面向过程的写法，当主题变化时，初始化三个显示屏并执行update方法
1. 好的设计：
  * 接口有Subject（包含方法registerObserver、removeObserver、notifyObservers），对应的实现类是WeatherData（包含属性Temperature、Humidity、Pressure）
  * 接口有Observer（包含方法update），对应的实现类是三个显示屏
1. oo原则：为交互对象之间的松耦合设计而努力
1. oo模式：在对象之间定义一对多的依赖，这样一来，当一个对象改变状态，依赖它的对象都会收到通知

#### 装饰者模式
1. 案例：星巴克的咖啡有室内混搭、焦炒、脱咖啡因，调料有牛奶、豆浆、摩卡
1. 坏的设计1：基类有Beverage（包含方法getDescription、cost），子类是HouseBlendWithMilk、HouseBlendWithSoy等等
1. 坏的设计2：基类有Beverage（包含方法getDescription、cost，包含属性Milk、Soy、Mocha），子类HouseBlend（通过setter修改属性Milk、Soy、Mocha，重写cost方法）
1. 好的设计：
  * 基类有Beverage（包含方法getDescription、cost），子类有HouseBlend、DarkRoast、Decaf和CondimentDecorator（包含属性beverage）
  * CondimentDecorator的子类有Milk、Soy、Mocha
  * 例如要一个HouseBlendWithMilk类，先实例化HouseBlend，再用Milk类来装饰
1. oo原则：对扩展开放，对修改关闭
1. oo模式：动态的将责任附加到对象上（而不是通过继承）

#### 工厂模式
1. 案例：披萨店生成各种口味披萨（简单工厂）；纽约店和芝加哥店同口味的披萨做法不同（工厂方法）；纽约店和芝加哥店需要各种本地原料（抽象工厂）
1. 坏的设计：对比简单工厂模式，用面向过程的写法，在客户端写if-else语句来创建不同的披萨
1. 好的设计：简单工厂模式
1. oo原则：依赖抽象，不要依赖具体类
1. oo模式：
  * 工厂方法：定义了创建对象的接口，由子类来决定如何创建
  * 抽象工厂：定义了创建产品家族的接口，同时产品也是抽象

#### 单例模式
1. 案例：用锅炉融化牛奶和巧克力，锅炉只能有一个
1. 坏的设计：用全局变量来保存类实例
1. 好的设计：用单例模式，可以延迟实例化，需注意并发导致实例化多次
1. oo模式：确保一个类只有一个实例

#### 命令模式
1. 案例1：用户点菜下单，服务员把单子交给厨师，厨师做好菜。服务员和厨师解耦，服务员不需要知道是哪个厨师做、如何做这些菜
1. 案例2：一个遥控器控制五种家电的开和关：卧室灯、厨房灯、吊扇、车库门、音响
1. 坏的设计：面向过程的写法，遥控器写大量的if-else来实现按钮和对应的事件
1. 好的设计：控制器是Invoker，Command数组绑定5个Command，Command关联卧室灯、厨房灯、吊扇、车库门、音响
1. oo模式：将请求封装成对象，让请求成为标准化的处理物品

#### 适配器模式
1. 案例：把火鸡当作鸭子，需要一个继承鸭类的适配器类
1. 坏的设计：直接修改现有的火鸡类
1. 好的设计：设计一个继承鸭类的适配器类，这样就不用修改原有的代码
1. oo模式：将一个类转换成用户期望的另一个类

#### 外观模式
1. 案例：打开家庭影院模式：打开爆米花机、灯光10%、屏幕放下、打开投影机、音响设置环绕立体音、DVD播放影片
1. 坏的设计：面向过程的写法，客户端直接写打开爆米花机、灯光10%、屏幕放下、打开投影机、音响设置环绕立体音、DVD播放影片
1. 好的设计：设计一个外观类，提供简单的操作接口，客户端只需要和外观类打交道
1. oo原则：最少知道原则
1. oo模式：封装内部子系统，对外提供统一的、简单的接口

#### 模板方法
1. 案例：星巴克泡咖啡/茶的秘方共同点：把水煮沸、泡咖啡/茶、泡好倒入被子、加上调料
1. 坏的设计：泡咖啡和泡茶独自写一个类，缺点是两者有重复的代码
1. 好的设计：设计一个公共的抽象类，泡咖啡和泡茶继承它并实现有差异的部分
1. oo原则：好莱坞原则（别找我，我会找你），由高层决定when、how使用低层组件
1. oo模式：定义一个算法的骨架，把变化的部分延迟到子类去实现

#### 迭代器模式
1. 案例：服务员需要将两个餐厅的菜单合并，A餐厅使用ArrayList，B餐厅使用数组
1. 坏的设计：面向过程的写法，先展示A餐厅的菜单，再展示B餐厅的菜单
1. 好的设计：两个餐厅仅暴露一个获取迭代器的方法，服务员据此获取迭代器，并展示数据
1. oo原则：单一职责原则，一个类只有一个引起变化的原因
1. oo模式：提供一个方法顺序访问聚合对象内部的元素，而不暴露其内部的实现

#### 组合模式
1. 案例：服务员需要提供一个树状菜单：A菜单、B菜单、C菜单，C菜单的一个子项是D菜单
1. 好的设计：每个节点可以是menu也可以是menuItem，两者继承menuComponent类
1. oo模式：让客户端以一致的方式处理对象或对象组合

#### 状态模式
1. 案例：糖果机有4个按钮4个状态：投币、退币、转动曲柄、发放糖果、；已投币、未投币、售罄、售出
1. 坏的设计：糖果机实现四个方法：投币、退币、转动曲柄、发放糖果，每个都需要写if-else判断
1. 好的设计：糖果机有一个表示状态属性，由状态去处理四个动作
1. oo模式：允许对象在内部状态改变时改变它的行为，对象看起来像修改了它的类

#### 代理模式
1. 代理模式控制客户端对对象的访问，有多种方式：
  * 远程代理：实现远程访问对象
  * 虚拟代理：控制实例化开销大的对象
  * 保护代理：设置对对象的访问规则
1. oo模式：为另一个对象提供替身或者占位符以访问这个对象


